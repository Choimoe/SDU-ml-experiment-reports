	% 代码分析：模块功能、涉及到的类、类关系、数据结构及关键代码等；
	% 任务要求，设计任务要求；
	% 设计：详细的设计方案，相关的数据结构、算法描述，可采用伪代码等形式化描述
	% 实现：修改哪些类、如何修改、为什么修改等；
	% 测试：测试用例，测试结果及结果分析，测试运行界面等；
	% 调试：调试方法，遇到的问题及解决方案等；
	% 结论与展望：完成的主要工作、收获、进一步的工作，建议、体会、心得等；

\section{Experiment 5.1 LDA for 2 Classes}

\subsection{预处理数据}

首先读取数据：

\begin{lstlisting}[language=matlab,title={读入 ex3?.dat}]
blueData = load('../exp5/ex3blue.dat');
redData = load('../exp5/ex3red.dat');
\end{lstlisting}

\subsection{数据可视化}

\begin{lstlisting}[language=matlab,title={plotData.m}]
function plotData(blueData, redData)
    figure;
    scatter(blueData(:, 1), blueData(:, 2), 'b', 'filled');
    hold on;
    scatter(redData(:, 1), redData(:, 2), 'r', 'filled');
    xlabel('X');
    ylabel('Y');
    title('Scatter Plot with Projection Line');
    legend({'Blue Point', 'Red Point'}, 'Location', 'northeast');
    axis equal;
end
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includesvg[width=10cm]{imgs/5-1-1.svg}
\end{figure} 

\subsection{Linear Discriminant Analysis-Two Classes}

首先求出均值向量：

\[
{\mathbf{\mu }}_{i} = \frac{1}{{n}_{i}}\mathop{\sum }\limits_{{x \in  {C}_{i}}}\mathbf{x}\quad{\widetilde{\mathbf{\mu }}}_{i} = \frac{1}{{n}_{i}}\mathop{\sum }\limits_{{y \in  {C}_{i}}}y = \frac{1}{{n}_{i}}\mathop{\sum }\limits_{{x \in  {C}_{i}}}{\mathbf{\theta }}^{T}\mathbf{x} = {\mathbf{\theta }}^{T}{\mathbf{\mu }}_{i}
\]

\begin{lstlisting}[language=matlab,title={computeMeans.m}]
function [meanBlue, meanRed] = computeMeans(blueData, redData)
    meanBlue = mean(blueData);
    meanRed = mean(redData);
end
\end{lstlisting}

需要最大化两类之间的间距：

\[
{J}_{1}\left( \mathbf{\theta }\right)  = {\left( {\widetilde{\mu }}_{1} - {\widetilde{\mu }}_{2}\right) }^{2} = {\left( {\mathbf{\theta }}^{T}{\mathbf{\mu }}_{1} - {\mathbf{\theta }}^{T}{\mathbf{\mu }}_{2}\right) }^{2} = {\mathbf{\theta }}^{T}\left( {{\mathbf{\mu }}_{1} - {\mathbf{\mu }}_{2}}\right) {\left( {\mathbf{\mu }}_{1} - {\mathbf{\mu }}_{2}\right) }^{T}\mathbf{\theta } = {\mathbf{\theta }}^{T}{\mathbf{S}}_{b}\mathbf{\theta }
\]

其中 $\mathbf{S}_b$ 称为类间散度矩阵 ${\mathbf{S}}_{b} = \left( {{\mathbf{\mu }}_{1} - {\mathbf{\mu }}_{2}}\right) {\left( {\mathbf{\mu }}_{1} - {\mathbf{\mu }}_{2}\right) }^{T}$。

还需要最小化类内的间距：

\[
{J}_{2}\left( \mathbf{\theta }\right)  = \mathop{\sum }\limits_{{y \in  {C}_{1}}}{\left( y - {\widetilde{\mu }}_{1}\right) }^{2} + \mathop{\sum }\limits_{{y \in  {C}_{2}}}{\left( y - {\widetilde{\mu }}_{2}\right) }^{2} = {\mathbf{\theta }}^{T}{\mathbf{S}}_{w}\mathbf{\theta }
\]

其中 $\mathbf{S}_w$ 称为类内散度矩阵 ${S}_{w} = \mathop{\sum }\limits_{{x \in  {C}_{1}}}\left( {x - {\mu }_{1}}\right) {\left( x - {\mu }_{1}\right) }^{T} + \mathop{\sum }\limits_{{x \in  {C}_{2}}}\left( {x - {\mu }_{2}}\right) {\left( x - {\mu }_{2}\right) }^{T}$。

\begin{lstlisting}[language=matlab,title={computeWithinClassScatter.m}]
function Sw = computeWithinClassScatter(blueData, redData)
    covBlue = cov(blueData);
    covRed = cov(redData);
    Sw = covBlue + covRed;
end
\end{lstlisting}

通过拉格朗日乘子法可以求得所求直线的方向向量：

\[
{\mathbf{\theta }}^{ * } = {\mathbf{S}}_{w}^{-1}\left( {{\mathbf{\mu }}_{1} - {\mathbf{\mu }}_{2}}\right)
\]

\begin{lstlisting}[language=matlab,title={computeLDAProjection.m}]
function w = computeLDAProjection(Sw, meanBlue, meanRed)
    w = inv(Sw) * (meanBlue' - meanRed');
end
\end{lstlisting}

于是不难写出代码：

\begin{lstlisting}[language=matlab,title={main.m}]
clear;

blueData = load('../exp5/ex3blue.dat');
redData = load('../exp5/ex3red.dat');

plotData(blueData, redData);
[meanBlue, meanRed] = computeMeans(blueData, redData);
Sw = computeWithinClassScatter(blueData, redData);
w = computeLDAProjection(Sw, meanBlue, meanRed);
plotProjectionLine(w, blueData, redData);
plotPerpendiculars(blueData, redData, w);
\end{lstlisting}

其中绘图部分的代码为：

\begin{lstlisting}[language=matlab,title={plotProjectionLine.m}]
function plotProjectionLine(w, blueData, redData)
    k = w(2) / w(1);
    xMin = min([blueData(:, 1); redData(:, 1)]) - 1;
    xMax = max([blueData(:, 1); redData(:, 1)]) + 1;
    xRange = linspace(xMin, xMax * sqrt(2), 100);
    yRange = k * xRange;
    plot(xRange, yRange, 'k--', 'LineWidth', 1.5);
    legend({'Blue Point', 'Red Point', 'Projection Line'}, 'Location', 'northeast');
end
\end{lstlisting}

\begin{lstlisting}[language=matlab,title={plotPerpendiculars.m}]
function plotPerpendiculars(blueData, redData, w)
    k = w(2) / w(1);
    for i = 1:size(blueData, 1)
        [xFoot, yFoot] = findFoot(blueData(i, :), k);
        plot([blueData(i, 1), xFoot], [blueData(i, 2), yFoot], '--b', 'HandleVisibility', 'off');
        plot(xFoot, yFoot, 'ob', 'HandleVisibility', 'off');
    end
    for i = 1:size(redData, 1)
        [xFoot, yFoot] = findFoot(redData(i, :), k);
        plot([redData(i, 1), xFoot], [redData(i, 2), yFoot], '--r', 'HandleVisibility', 'off');
        plot(xFoot, yFoot, 'or', 'HandleVisibility', 'off');
    end
end

\end{lstlisting}

可以得到结果

\begin{figure}[H]
    \centering
    \includesvg[width=10cm]{imgs/5-1-2.svg}
\end{figure} 

\section{Experiment 5.2 LDA for N Classes}

\subsection{预处理数据}

首先读取数据：

\begin{lstlisting}[language=matlab,title={读入 ex3?.dat}]
ex3blue = load('../exp5/ex3blue.dat');
ex3green = load('../exp5/ex3green.dat');
ex3red = load('../exp5/ex3red.dat');
\end{lstlisting}

\subsection{Linear Discriminant Analysis- C Classes}

对于 $C$ 类的情况，可能有 $p\leq C-1$ 个 projection vectors：

\[
{\mathbf{S}}_{w}^{-1}{\mathbf{S}}_{b}{\mathbf{\theta }}_{i} = \lambda {\mathbf{\theta }}_{i},i = 1,2,\ldots ,p
\]

${{\Theta }}^{ * }$ 的列是对应于最大特征值的特征向量：

\[
\begin{matrix} {\mathbf{S}}_{w}^{-1}{\mathbf{S}}_{b}{{\Theta }}^{ * } = \lambda {{\Theta }}^{ * } & & & {{\Theta }}^{ * } = \left\lbrack  {{\mathbf{\theta }}_{1}^{ * },{\mathbf{\theta }}_{2}^{ * },...,{\mathbf{\theta }}_{p}^{ * }}\right\rbrack   \end{matrix}
\]

实际计算过程与 2 Classes 类似，但计算类内散度矩阵、计算类间散度矩阵的方式有变化：

对于类内散度矩阵，有：

\[
\begin{matrix} {\mathbf{S}}_{w} = \mathop{\sum }\limits_{{i = 1}}^{C}{\mathbf{S}}_{wi} & & {\mathbf{S}}_{wi} = \mathop{\sum }\limits_{{\mathbf{x} \in  \mathbf{{C}_{i}}}}\left( {\mathbf{x} - {\mathbf{\mu }}_{i}}\right) {\left( \mathbf{x} - {\mathbf{\mu }}_{i}\right) }^{T} & & & {\mathbf{S}}_{w} \in  {\mathbb{R}}^{d \times  d} \end{matrix}
\]

\begin{lstlisting}[language=matlab,title={computeWithinClassScatter.m}]
function Sw = computeWithinClassScatter(X, y)
    uniqueClasses = unique(y);
    Sw = zeros(size(X,2), size(X,2));
    for i = 1:length(uniqueClasses)
        class_idx = (y == uniqueClasses(i));
        Xi = X(class_idx, :);
        mu_i = mean(Xi);
        Xi = Xi - mu_i;
        Sw = Sw + Xi' * Xi;
    end
end
\end{lstlisting}

对于类间散度矩阵，有：

\[
\begin{array}{lll} {\mathbf{S}}_{b} = \mathop{\sum }\limits_{{i = 1}}^{C}{n}_{i}\left( {{\mathbf{\mu }}_{i} - \mathbf{\mu }}\right) {\left( {\mathbf{\mu }}_{i} - \mathbf{\mu }\right) }^{T} = \frac{1}{2N}\mathop{\sum }\limits_{{i,j = 1}}^{C}{n}_{i}{n}_{j}\left( {{\mathbf{\mu }}_{i} - {\mathbf{\mu }}_{j}}\right) {\left( {\mathbf{\mu }}_{i} - {\mathbf{\mu }}_{j}\right) }^{T} & & {\mathbf{S}}_{b} \in  {\mathbb{R}}^{d \times  d} \end{array}
\]

\begin{lstlisting}[language=matlab,title={computeBetweenClassScatter.m}]
function Sb = computeBetweenClassScatter(X, y)
    mu = mean(X);
    Sb = zeros(size(X,2), size(X,2));
    uniqueClasses = unique(y);
    for i = 1:length(uniqueClasses)
        class_idx = (y == uniqueClasses(i));
        Xi = X(class_idx, :);
        ni = size(Xi, 1);
        mu_i = mean(Xi);
        mu_diff = mu_i - mu;
        Sb = Sb + ni * (mu_diff' * mu_diff);
    end
end
\end{lstlisting}

可以得到结果：

\begin{figure}[H]
    \centering
    \includesvg[width=10cm]{imgs/5-1-3.svg}
\end{figure} 

\subsection{完整代码}

\begin{lstlisting}[language=matlab,title={main.m}]
clear;

ex3blue = load('../exp5/ex3blue.dat');
ex3green = load('../exp5/ex3green.dat');
ex3red = load('../exp5/ex3red.dat');
X = [ex3blue; ex3green; ex3red];
y = [ones(size(ex3blue,1),1); 2*ones(size(ex3green,1),1); 3*ones(size(ex3red,1),1)];

Sw = computeWithinClassScatter(X, y);
Sb = computeBetweenClassScatter(X, y);

[~, ~, V] = svd(inv(Sw) * Sb);
w = V(:, 1);
k = w(2) / w(1);

xRange = [0, max(10, max(X(:, 1)))];
yRange = k * xRange;

figure;
hold on;
scatter(ex3blue(:,1), ex3blue(:,2), 'b', 'filled', 'DisplayName', 'Blue Point');
scatter(ex3green(:,1), ex3green(:,2), 'g', 'filled', 'DisplayName', 'Green Point');
scatter(ex3red(:,1), ex3red(:,2), 'r', 'filled', 'DisplayName', 'Red Point');
plot(xRange, yRange, 'k--', 'LineWidth', 2, 'DisplayName', 'Projection Line');
legend;

axis equal;
xlabel('X');
ylabel('Y');
title('Scatter Plot with Projection Line');

plotPerpendiculars(ex3blue, w, 'b');
plotPerpendiculars(ex3green, w, 'g');
plotPerpendiculars(ex3red, w, 'r');

hold off;
\end{lstlisting}


